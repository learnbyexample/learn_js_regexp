<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Groupings and backreferences - JavaScript RegExp</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Example based guide to mastering JavaScript regexp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cover.html">Cover</a></li><li class="chapter-item expanded affix "><a href="buy.html">Buy PDF/EPUB versions</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><a href="whats-so-special-about-regular-expressions.html"><strong aria-hidden="true">2.</strong> What's so special about Regular Expressions?</a></li><li class="chapter-item expanded "><a href="regexp-introduction.html"><strong aria-hidden="true">3.</strong> RegExp introduction</a></li><li class="chapter-item expanded "><a href="anchors.html"><strong aria-hidden="true">4.</strong> Anchors</a></li><li class="chapter-item expanded "><a href="alternation-and-grouping.html"><strong aria-hidden="true">5.</strong> Alternation and Grouping</a></li><li class="chapter-item expanded "><a href="escaping-metacharacters.html"><strong aria-hidden="true">6.</strong> Escaping metacharacters</a></li><li class="chapter-item expanded "><a href="dot-metacharacter-and-quantifiers.html"><strong aria-hidden="true">7.</strong> Dot metacharacter and Quantifiers</a></li><li class="chapter-item expanded "><a href="interlude-tools-for-debugging-and-visualization.html"><strong aria-hidden="true">8.</strong> Interlude: Tools for debugging and visualization</a></li><li class="chapter-item expanded "><a href="working-with-matched-portions.html"><strong aria-hidden="true">9.</strong> Working with matched portions</a></li><li class="chapter-item expanded "><a href="character-class.html"><strong aria-hidden="true">10.</strong> Character class</a></li><li class="chapter-item expanded "><a href="groupings-and-backreferences.html" class="active"><strong aria-hidden="true">11.</strong> Groupings and backreferences</a></li><li class="chapter-item expanded "><a href="interlude-common-tasks.html"><strong aria-hidden="true">12.</strong> Interlude: Common tasks</a></li><li class="chapter-item expanded "><a href="lookarounds.html"><strong aria-hidden="true">13.</strong> Lookarounds</a></li><li class="chapter-item expanded "><a href="unicode.html"><strong aria-hidden="true">14.</strong> Unicode</a></li><li class="chapter-item expanded "><a href="further-reading.html"><strong aria-hidden="true">15.</strong> Further Reading</a></li><li class="chapter-item expanded "><a href="Exercise_solutions.html"><strong aria-hidden="true">16.</strong> Exercise Solutions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">JavaScript RegExp</h1>

                    <div class="right-buttons">
                        
                        <a href="https://github.com/learnbyexample/learn_js_regexp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#groupings-and-backreferences" id="groupings-and-backreferences">Groupings and backreferences</a></h1>
<p>This chapter will show how to reuse portion matched by capture groups via backreferences within regexp definition and replacement section. You'll also learn some special grouping syntax for cases where plain capture groups isn't enough.</p>
<h2><a class="header" href="#backreferences" id="backreferences">Backreferences</a></h2>
<p>First up, how to refer to capture group portions directly in regexp definition and replacement section. You have already seen how to refer to text captured by groups with <code>match</code> and <code>matchAll</code> methods. You've also seen how to pass captured portions to a function in <code>replace</code> method. More directly, you can use backreference <code>\N</code> (within the regexp definition) and <code>$N</code> (replacement section), where <code>N</code> is the capture group you want. What's more, you can also apply quantifiers to backreferences when used in regexp definition. All the various forms is listed below:</p>
<ul>
<li>in replacement section, use <code>$1</code>, <code>$2</code>, etc to refer to the corresponding capture group</li>
<li>in replacement section, use <code>$&amp;</code> to refer to entire matched portion
<ul>
<li><code>$`</code> gives string before the matched portion</li>
<li><code>$'</code> gives string after the matched portion</li>
</ul>
</li>
<li>within regexp definition, use <code>\1</code>, <code>\2</code>, etc to refer to the corresponding capture group</li>
</ul>
<pre><code class="language-js">// remove square brackets that surround digit characters
&gt; '[52] apples [and] [31] mangoes'.replace(/\[(\d+)\]/g, '$1')
&lt; &quot;52 apples [and] 31 mangoes&quot;

// replace __ with _ and delete _ if it is alone
&gt; '_foo_ __123__ _baz_'.replace(/(_)?_/g, '$1')
&lt; &quot;foo _123_ baz&quot;

// swap words that are separated by a comma
&gt; 'good,bad 42,24'.replace(/(\w+),(\w+)/g, '$2,$1')
&lt; &quot;bad,good 24,42&quot;
</code></pre>
<p>Here's some examples for using backreferences available by default without needing capture groups.</p>
<pre><code class="language-js">// add something around the entire matched portion
&gt; '52 apples and 31 mangoes'.replace(/\d+/g, '($&amp;)')
&lt; &quot;(52) apples and (31) mangoes&quot;
&gt; 'Hello world'.replace(/.*/, 'Hi. $&amp;. Have a nice day')
&lt; &quot;Hi. Hello world. Have a nice day&quot;

// duplicate first field and add it as last field
&gt; 'fork,42,nice,3.14'.replace(/,.+/, '$&amp;,$`')
&lt; &quot;fork,42,nice,3.14,fork&quot;
</code></pre>
<p>And here's some examples for using backreferences within regexp definition.</p>
<pre><code class="language-js">// elements that have at least one consecutive repeated word character
&gt; let words = ['moon', 'mono', 'excellent', 'poll']
&gt; words.filter(w =&gt; /(\w)\1/.test(w))
&lt; [&quot;moon&quot;, &quot;excellent&quot;, &quot;poll&quot;]

// remove any number of consecutive duplicate words separated by space
// note the use of quantifier on backreference
// use \W+ instead of space to cover cases like 'a;a&lt;-;a'
&gt; 'aa a a a 42 f_1 f_1 f_13.14'.replace(/\b(\w+)( \1)+\b/g, '$1')
&lt; &quot;aa a 42 f_1 f_13.14&quot;
</code></pre>
<h2><a class="header" href="#backreference-oddities" id="backreference-oddities">Backreference oddities</a></h2>
<p>Since <code>$</code> is special in replacement section, there's an issue to place it literally if followed by numbers. Usually, escaping is used for such purposes, but here you need to use <code>$$</code>.</p>
<pre><code class="language-js">// no capture group used, so '$1' is inserted literally
&gt; 'cat'.replace(/a/, '{$1}')
&lt; &quot;c{$1}t&quot;
// capture group used, '\$1' is same as '$1' here
&gt; 'cat'.replace(/(a)/, '{\$1}')
&lt; &quot;c{a}t&quot;

// use '$$' to avoid backreference and insert '$' literally
&gt; 'cat'.replace(/(a)/, '{$$1}')
&lt; &quot;c{$1}t&quot;
</code></pre>
<p>Another issue is how to avoid ambiguity when you have normal digits immediately following a backreference? It'll depend on how many backreferences are present in the pattern and whether you need to avoid ambiguity in regexp definition or replacement section. For example, if there are less than 10 groups, then something like <code>$12</code> will refer to first capture group and <code>2</code> as a character. If there are no capture groups, then something like <code>$5</code> will get inserted literally as <code>$</code> and <code>5</code>.</p>
<pre><code class="language-js">// $15 here will backreference 1st group and use 5 as a character
&gt; '[52] apples and [31] mangoes'.replace(/\[(\d+)\]/g, '($15)')
&lt; &quot;(525) apples and (315) mangoes&quot;

// $3 will be inserted literally since there is only one capture group
&gt; '[52] apples and [31] mangoes'.replace(/\[(\d+)\]/g, '$3')
&lt; &quot;$3 apples and $3 mangoes&quot;

// $1 will be inserted literally since there are no capture groups
&gt; '[52] apples and [31] mangoes'.replace(/\[\d+\]/g, '$1')
&lt; &quot;$1 apples and $1 mangoes&quot;
</code></pre>
<p>On the other hand, if you have more than <code>9</code> but less than <code>100</code> groups, then there would be an issue if you want to refer to single digit group followed by literal digit characters. The workaround is to prefix <code>0</code> such that number of digits after <code>$</code> equals the number of digits required for the highest capture group. So, if you have more than <code>9</code> but less than <code>100</code> groups, <code>$05</code> will refer to 5th capture group and any digit after that will be treated literally.</p>
<pre><code class="language-js">// for illustration purposes, 12 capture groups have been defined here
// if you want to reference 2-digit group, there's no issue
&gt; 'abcdefghijklmn'.replace(/(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/, '$11')
&lt; &quot;kmn&quot;

// what if you wanted to reference 1st group followed by '1' as a character?
// using \x31 wouldn't work as it still results in $11
&gt; 'abcdefghijklmn'.replace(/(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/, '$1\x31')
&lt; &quot;kmn&quot;
// prefix a '0' so that '$01' becomes the reference and '1' becomes character
&gt; 'abcdefghijklmn'.replace(/(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)/, '$011')
&lt; &quot;a1mn&quot;
</code></pre>
<p>The workaround is simpler in regexp definition. The <code>0</code> prefix trick doesn't work, but using ASCII code with <code>\xhh</code> works. For example, <code>\1\x31</code> will refer to first capture group followed by <code>1</code> as a character.</p>
<pre><code class="language-js">&gt; 'abcdefghijklmna1d'.replace(/(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.).*\1\x31/, 'X')
&lt; &quot;Xd&quot;
</code></pre>
<h2><a class="header" href="#non-capturing-groups" id="non-capturing-groups">Non-capturing groups</a></h2>
<p>Grouping has many uses like applying quantifier on a regexp portion, creating terse regexp by factoring common portions and so on. It also affects the output of <code>split</code> method as seen in <a href="./working-with-matched-portions.html#split-with-capture-groups">split with capture groups</a> section. Unlike similar methods in other languages, <code>match</code> method with <code>g</code> flag isn't affected by capture groups and returns entire matched portions.</p>
<pre><code class="language-js">// split method without capture group
&gt; 'Sample123string42with777numbers'.split(/\d+/)
&lt; [&quot;Sample&quot;, &quot;string&quot;, &quot;with&quot;, &quot;numbers&quot;]
// split method with capture group
&gt; 'Sample123string42with777numbers'.split(/(\d+)/)
&lt; [&quot;Sample&quot;, &quot;123&quot;, &quot;string&quot;, &quot;42&quot;, &quot;with&quot;, &quot;777&quot;, &quot;numbers&quot;]

// match method example with 'g' flag and capture groups
&gt; 'effort flee facade oddball rat tool'.match(/\b\w*(\w)\1\w*\b/g)
&lt; [&quot;effort&quot;, &quot;flee&quot;, &quot;oddball&quot;, &quot;tool&quot;]
// here's another example
&gt; 'hi 123123123 bye 456123456'.match(/(123)+/g)
&lt; [&quot;123123123&quot;, &quot;123&quot;]
</code></pre>
<p>When backreferencing is not required, you can use a non-capturing group to avoid behavior change of <code>split</code> method. It also helps to avoid keeping a track of capture group numbers when that particular group is not needed for backreferencing. The syntax is <code>(?:pat)</code> to define a non-capturing group, where <code>pat</code> is an abbreviation for a portion of regular expression pattern. More such special groups starting with <code>(?</code> syntax will be discussed later on.</p>
<pre><code class="language-js">// here, grouping is needed to take out common portion and apply quantifier
// but using capture group will not give expected output
&gt; '123hand42handy777handful500'.split(/hand(y|ful)?/)
&lt; [&quot;123&quot;, undefined, &quot;42&quot;, &quot;y&quot;, &quot;777&quot;, &quot;ful&quot;, &quot;500&quot;]
// non-capturing group to the rescue
&gt; '123hand42handy777handful500'.split(/hand(?:y|ful)?/)
&lt; [&quot;123&quot;, &quot;42&quot;, &quot;777&quot;, &quot;500&quot;]

// with normal grouping, need to keep track of all the groups
&gt; '1,2,3,4,5,6,7'.replace(/^(([^,]+,){3})([^,]+)/, '$1($3)')
&lt; &quot;1,2,3,(4),5,6,7&quot;
// using non-capturing groups, only relevant groups have to be tracked
&gt; '1,2,3,4,5,6,7'.replace(/^((?:[^,]+,){3})([^,]+)/, '$1($2)')
&lt; &quot;1,2,3,(4),5,6,7&quot;
</code></pre>
<p>Referring to text matched by a capture group with a quantifier will give only the last match, not entire match. Use a capture group around the grouping and quantifier together to get the entire matching portion. In such cases, the inner grouping is an ideal candidate to use non-capturing group.</p>
<pre><code class="language-js">// '$1' here contains only the fourth field
&gt; 'so:cat:rest:in:put:to'.replace(/^([^:]+:){4}/, '($1)')
&lt; &quot;(in:)put:to&quot;

// '$1' will now contain the entire matching portion
&gt; 'so:cat:rest:in:put:to'.replace(/^((?:[^:]+:){4})/, '($1)')
&lt; &quot;(so:cat:rest:in:)put:to&quot;
</code></pre>
<h2><a class="header" href="#named-capture-groups" id="named-capture-groups">Named capture groups</a></h2>
<p>Regexp can get cryptic and difficult to maintain, even for seasoned programmers. There are a few constructs to help add clarity. One such is naming the capture groups and using that name for backreferencing instead of plain numbers. In addition, the named capture group portions can be extracted as key-value pairs using the <code>groups</code> property. The syntax is:</p>
<ul>
<li><code>(?&lt;name&gt;pat)</code> for naming the capture groups</li>
<li><code>\k&lt;name&gt;</code> for backreferencing in regexp definition</li>
<li><code>$&lt;name&gt;</code> for backreferencing in replacement section</li>
</ul>
<pre><code class="language-js">&gt; let row = 'today,2008-03-24,food,2008-03-24,nice,2018-10-25,5632'

// same as: /(\d{4}-\d{2}-\d{2}).*\1/
&gt; row.match(/(?&lt;date&gt;\d{4}-\d{2}-\d{2}).*\k&lt;date&gt;/)[0]
&lt; &quot;2008-03-24,food,2008-03-24&quot;

// giving names to first and second captured words
// same as: replace(/(\w+),(\w+)/g, '$2,$1')
&gt; 'good,bad 42,24'.replace(/(?&lt;fw&gt;\w+),(?&lt;sw&gt;\w+)/g, '$&lt;sw&gt;,$&lt;fw&gt;')
&lt; &quot;bad,good 24,42&quot;
</code></pre>
<p>Here's an example with <code>groups</code> property.</p>
<pre><code class="language-js">&gt; let m = '2018-10-25,car'.match(/(?&lt;date&gt;[^,]+),(?&lt;product&gt;[^,]+)/)

&gt; m.groups
&lt; {date: &quot;2018-10-25&quot;, product: &quot;car&quot;}
&gt; m.groups.date
&lt; &quot;2018-10-25&quot;
&gt; m.groups.product
&lt; &quot;car&quot;
</code></pre>
<h2><a class="header" href="#cheatsheet-and-summary" id="cheatsheet-and-summary">Cheatsheet and Summary</a></h2>
<table><thead><tr><th>Note</th><th>Description</th></tr></thead><tbody>
<tr><td>Backreference</td><td>gives matched portion of Nth capture group</td></tr>
<tr><td></td><td>use <code>$1</code>, <code>$2</code>, <code>$3</code>, etc in replacement section</td></tr>
<tr><td></td><td><code>$&amp;</code> gives entire matched portion</td></tr>
<tr><td></td><td><code>$`</code> gives string before the matched portion</td></tr>
<tr><td></td><td><code>$'</code> gives string after the matched portion</td></tr>
<tr><td></td><td>use <code>\1</code>, <code>\2</code>, <code>\3</code>, etc within regexp definition</td></tr>
<tr><td><code>$$</code></td><td>insert <code>$</code> literally in replacement section</td></tr>
<tr><td><code>$0N</code></td><td>same as <code>$N</code>, allows to separate backreference and other digits</td></tr>
<tr><td><code>\N\xhh</code></td><td>allows to separate backreference and digits in regexp definition</td></tr>
<tr><td><code>(?:pat)</code></td><td>non-capturing group</td></tr>
<tr><td><code>(?&lt;name&gt;pat)</code></td><td>named capture group</td></tr>
<tr><td></td><td>use <code>\k&lt;name&gt;</code> for backreferencing in regexp definition</td></tr>
<tr><td></td><td>use <code>$&lt;name&gt;</code> for backreferencing in replacement section</td></tr>
<tr><td></td><td>named captures are also accessible via <code>groups</code> property</td></tr>
</tbody></table>
<p>This chapter covered many more features related to grouping â€” backreferencing to get matched portion of capture groups and naming the groups to add clarity. When capture groups results in unwanted behavior change (ex: <code>split</code> method), you can use non-capturing groups instead. You'll see more such special groups in <a href="./lookarounds.html#lookarounds">Lookarounds</a> chapter.</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<p><strong>a)</strong> Replace the space character that occurs after a word ending with <code>a</code> or <code>r</code> with a newline character.</p>
<pre><code class="language-js">&gt; let ip = 'area not a _a2_ roar took 22'

&gt; console.log()     // add your solution here
  area
  not a
  _a2_ roar
  took 22
</code></pre>
<p><strong>b)</strong> Add <code>[]</code> around words starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order.</p>
<pre><code class="language-js">&gt; let ip = 'sequoia subtle exhibit asset sets tests site'

// add your solution here
&lt; &quot;sequoia [subtle] exhibit asset [sets] tests [site]&quot;
</code></pre>
<p><strong>c)</strong> Replace all whole words with <code>X</code> that start and end with the same word character. Single character word should get replaced with <code>X</code> too, as it satisfies the stated condition.</p>
<pre><code class="language-js">&gt; let ip = 'oreo not a _a2_ roar took 22'

// add your solution here
&lt; &quot;X not X X X took X&quot;
</code></pre>
<p><strong>d)</strong> Convert the given <strong>markdown</strong> headers to corresponding <strong>anchor</strong> tag. Consider the input to start with one or more <code>#</code> characters followed by space and word characters. The <code>name</code> attribute is constructed by converting the header to lowercase and replacing spaces with hyphens. Can you do it without using a capture group?</p>
<pre><code class="language-js">&gt; let header1 = '# Regular Expressions'
&gt; let header2 = '## Named capture groups'

&gt; function hyphenify(m) {
      // add your solution here
  }

&gt; header1.replace()     // add your solution here
&lt; &quot;# &lt;a name='regular-expressions'&gt;&lt;/a&gt;Regular Expressions&quot;
&gt; header2.replace()     // add your solution here
&lt; &quot;## &lt;a name='named-capture-groups'&gt;&lt;/a&gt;Named capture groups&quot;
</code></pre>
<p><strong>e)</strong> Convert the given <strong>markdown</strong> anchors to corresponding <strong>hyperlinks</strong>.</p>
<pre><code class="language-js">&gt; let anchor1 = &quot;# &lt;a name='regular-expressions'&gt;&lt;/a&gt;Regular Expressions&quot;
&gt; let anchor2 = &quot;## &lt;a name='subexpression-calls'&gt;&lt;/a&gt;Subexpression calls&quot;

&gt; const hyperlink =         // add your solution here

&gt; anchor1.replace()         // add your solution here
&lt; &quot;[Regular Expressions](#regular-expressions)&quot;
&gt; anchor2.replace()         // add your solution here
&lt; &quot;[Subexpression calls](#subexpression-calls)&quot;
</code></pre>
<p><strong>f)</strong> Check if given input strings have words with at least two consecutive repeated alphabets irrespective of case. For example, words like <code>stillnesS</code> and <code>Committee</code> should return <code>true</code> but words like <code>root</code> or <code>readable</code> or <code>rotational</code> should return <code>false</code>. Consider word to be as defined in regular expression parlance.</p>
<pre><code class="language-js">&gt; let s1 = 'readable COMMItTEe'
&gt; let s2 = 'rotational sti1lness _foot_'
&gt; let s3 = 'needed repeated'
&gt; let s4 = 'offsh00t'

&gt; const pat1 =      // add your solution here

&gt; pat1.test(s1)
true
&gt; pat1.test(s2)
false
&gt; pat1.test(s3)
false
&gt; pat1.test(s4)
true
</code></pre>
<p><strong>g)</strong> For the given input string, replace all occurrences of digit sequences with only the unique non-repeating sequence. For example, <code>232323</code> should be changed to <code>23</code> and <code>897897</code> should be changed to <code>897</code>. If there no repeats (for example <code>1234</code>) or if the repeats end prematurely (for example <code>12121</code>), it should not be changed.</p>
<pre><code class="language-js">&gt; let ip = '1234 2323 453545354535 9339 11 60260260'

// add your solution here
&lt; &quot;1234 23 4535 9339 1 60260260&quot;
</code></pre>
<p><strong>h)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the first word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.</p>
<pre><code class="language-js">&gt; let ip = 'wow:Good:2_two:five: hi-2 bye kite.777.water.'

// add your solution here
&lt; &quot;wow hi-2 bye kite&quot;
</code></pre>
<p><strong>i)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the last word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.</p>
<pre><code class="language-js">&gt; let ip = 'wow:Good:2_two:five: hi-2 bye kite.777.water.'

// add your solution here
&lt; &quot;five hi-2 bye water&quot;
</code></pre>
<p><strong>j)</strong> Split the given input string on one or more repeated sequence of <code>cat</code>.</p>
<pre><code class="language-js">&gt; let ip = 'firecatlioncatcatcatbearcatcatparrot'

// add your solution here
&lt; [&quot;fire&quot;, &quot;lion&quot;, &quot;bear&quot;, &quot;parrot&quot;]
</code></pre>
<p><strong>k)</strong> For the given input string, find all occurrences of digit sequences with at least one repeating sequence. For example, <code>232323</code> and <code>897897</code>. If the repeats end prematurely, for example <code>12121</code>, it should not be matched.</p>
<pre><code class="language-js">&gt; let ip = '1234 2323 453545354535 9339 11 60260260'

&gt; const pat2 =      // add your solution here

// entire sequences in the output
// add your solution here
&lt; [&quot;2323&quot;, &quot;453545354535&quot;, &quot;11&quot;]

// only the unique sequence in the output
// add your solution here
&lt; [&quot;23&quot;, &quot;4535&quot;, &quot;1&quot;]
</code></pre>
<p><strong>l)</strong> Convert the comma separated strings to corresponding key-value pair mapping as shown below. The keys are <code>name</code>, <code>maths</code> and <code>phy</code> for the three fields in the input strings.</p>
<pre><code class="language-js">&gt; let row1 = 'rohan,75,89'
&gt; let row2 = 'rose,88,92'

&gt; const pat3 =      // add your solution here

// add your solution here for row1
&lt; {name: &quot;rohan&quot;, maths: &quot;75&quot;, phy: &quot;89&quot;}

// add your solution here for row2
&lt; {name: &quot;rose&quot;, maths: &quot;88&quot;, phy: &quot;92&quot;}
</code></pre>
<p><strong>m)</strong> Surround all whole words with <code>()</code>. Additionally, if the whole word is <code>imp</code> or <code>ant</code>, delete them. Can you do it with single substitution?</p>
<pre><code class="language-js">&gt; let ip = 'tiger imp goat eagle ant important'

// add your solution here
&lt; &quot;(tiger) () (goat) (eagle) () (important)&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="character-class.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="interlude-common-tasks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="character-class.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="interlude-common-tasks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
